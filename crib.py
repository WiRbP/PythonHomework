# ===============================================[ ШПОРА ]==============================================================
# Данная замтека будет служить фиксацией знаний полученных из книги
# Тут содержаться фрагменты кода, и мои коментарии к нему.

'''
                                   Работа с классами и инкапсуляцией

Класс это фрагмент кода в котором обявлены
атрибуты(характеристики) и методы(способ поведения/умение). Классы подобны чертежам - это НЕ объект Но схема объекта !

Параметр self автоматичиски становиться ссылкой на объект по отнашению к которому вызван метод.

Класссы принято называть с Болшой буквы !
'''

# ===============================================[ ГЛАВА 9 ]============================================================
'''
                                  ОБЪЕКТНОРИЕНТИРОВАНННОЕ ПРОГРАММИРОВАНИЕ 
'''

# Терминалогия: ['Отправка сообщения' - объекты вызывают методы друг-друга]
# Пример работы метода приведен ниже.

class Player(object):
    """ A player in a shooter game. """
    def blast(self, enemy): # Функция принимает в себя Цель которой в данном случае является Alien
        # Так называемая 'Отправка сообщения происходит посредствам команды' hero.blast(invader)
        print("The player blasts an enemy.\n")
        enemy.die() # данный метод будет вызывать атрибут внутри класса Alien
        # enemy в данном случае будет Alien следовательно после точки будет вызван метод его функции

class Alien(object):
    """ An alien in a shooter game. """
    def die(self):
        print("The alien gasps and says, 'Oh, this is it.  This is the big one. \n" \
              "Yes, it's getting dark now.  Tell my 1.6 million larvae that I loved them... \n" \
              "Good-bye, cruel universe.'")

# main
print("\t\tDeath of an Alien\n")

hero = Player()
invader = Alien()
hero.blast(invader)
# ----------------------------------------------------------------------------------------------------------------------
'''
                                              [ НАСЛЕДОВАНИЕ ]
'''


# class Name(ClassName) имя наследуюемого класса помощается внутрь скобок
# Переопределением метод называют изменение унаследованного метода
# Полиформизм это когда предметы одной группы неоднакртано реагируют наодну и туже операцию,
# в конктексте ООП это означает что одно и тоже сообщение можно посылать бъекам разных классов

class Positionable_Card(Card):
    """ Функция позволяет определить положение карты Лицом/Рубашкой вверх """
    def __init__(self, rank, suit, face_up = True):
        super(Positionable_Card, self).__init__(rank, suit) # функция super вызывает метод Базавого класса
        # Такие функции называются НАДклассом
        self.is_face_up = face_up





